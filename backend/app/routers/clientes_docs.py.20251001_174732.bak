from fastapi import APIRouter, UploadFile, File, HTTPException
from fastapi.responses import FileResponse
from pydantic import BaseModel
from sqlalchemy import text
from pathlib import Path
from typing import List
from ..deps import get_session
from . import clientes  # para usar la misma reflexión si la necesitas
from contextlib import contextmanager

router = APIRouter()

# misma ruta de uploads que main.py
UPLOAD_ROOT = Path(__file__).resolve().parents[2] / "uploads"

class DocOut(BaseModel):
    doc_id: int
    cliente_id: int
    filename: str
    content_type: str | None = None
    file_url: str

@router.post("/{cliente_id}/upload", response_model=DocOut)
async def upload_doc(cliente_id: int, archivo: UploadFile = File(...)):
    # guardar en disco
    UPLOAD_ROOT.mkdir(parents=True, exist_ok=True)
    target_dir = UPLOAD_ROOT / f"clientes/{cliente_id}"
    target_dir.mkdir(parents=True, exist_ok=True)
    dest = target_dir / archivo.filename

    # escribir archivo
    data = await archivo.read()
    dest.write_bytes(data)

    file_url = f"/uploads/clientes/{cliente_id}/{archivo.filename}"

    # registrar en BD
    from ..deps import get_session
    with get_session() as session:
        sql = text("""
            INSERT INTO ciad99_clientes_docs (cliente_id, filename, content_type, file_path)
            VALUES (:cliente_id, :filename, :content_type, :file_path)
            RETURNING doc_id, cliente_id, filename, content_type, file_path, uploaded_at;
        """)
        row = session.execute(sql, {
            "cliente_id": cliente_id,
            "filename": archivo.filename,
            "content_type": archivo.content_type,
            "file_path": str(dest)
        }).mappings().first()
        session.commit()

    return DocOut(
        doc_id=row["doc_id"],
        cliente_id=row["cliente_id"],
        filename=row["filename"],
        content_type=row["content_type"],
        file_url=file_url
    )

@router.get("/{cliente_id}/docs", response_model=List[DocOut])
def listar_docs(cliente_id: int):
    with get_session() as session:
        rows = session.execute(text("""
            SELECT doc_id, cliente_id, filename, content_type, file_path
            FROM ciad99_clientes_docs
            WHERE cliente_id = :cid
            ORDER BY uploaded_at DESC, doc_id DESC;
        """), {"cid": cliente_id}).mappings().all()

    out = []
    for r in rows:
        # construir URL pública
        path = Path(r["file_path"])
        try:
            rel = path.relative_to(UPLOAD_ROOT)
            file_url = f"/uploads/{rel.as_posix()}"
        except Exception:
            file_url = ""
        out.append(DocOut(
            doc_id=r["doc_id"],
            cliente_id=r["cliente_id"],
            filename=r["filename"],
            content_type=r["content_type"],
            file_url=file_url
        ))
    return out

@router.delete("/{cliente_id}/docs/{doc_id}")
def borrar_doc(cliente_id: int, doc_id: int):
    with get_session() as session:
        row = session.execute(text("""
            SELECT file_path FROM ciad99_clientes_docs
            WHERE doc_id=:doc AND cliente_id=:cid;
        """), {"doc": doc_id, "cid": cliente_id}).mappings().first()
        if not row:
            raise HTTPException(status_code=404, detail="Documento no encontrado")
        # borrar registro
        session.execute(text("""
            DELETE FROM ciad99_clientes_docs WHERE doc_id=:doc AND cliente_id=:cid;
        """), {"doc": doc_id, "cid": cliente_id})
        session.commit()
    # intentar borrar archivo
    try:
        Path(row["file_path"]).unlink(missing_ok=True)
    except Exception:
        pass
    return {"status": "ok", "deleted": True, "doc_id": doc_id}
